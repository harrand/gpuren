== default ==
{
	add_source_directory("src");
}

// initialise psygpu. you must call this before doing anything else. gpu_term() will undo this.
// gpu_err.malformed => you have already called gpu_init without prior termination
// gpu_err.reqfailed => your graphics setup/drivers do not meet the requirements to be used
// gpu_err.cpuoom => not enough cpu memory
// gpu_err.gpuoom => not enough gpu memory
// gpu_err.unknown => internal error, upto you to figure out
gpu_init ::= func(info : gpu_appinfo -> gpu_err)
{
	return impl_gpu_init(info);
};

// terminate psygpu. frees all cpu/gpu memory used by psygpu and invalidates all state. you will need to call gpu_init again to do anything.
// gpu_err.malformed => you have not called gpu_init or you have called gpu_term twice
gpu_term ::= func( -> gpu_err)
{
	return impl_gpu_term();
};

gpu_create_graph ::= func(name : u8?, a : arena mut? -> gpu_graph)
{
	return impl_gpu_create_graph(name, a);
};

gpu_graph_add_subgraph ::= func(g : gpu_graph, subgraph : gpu_graph, a : arena mut? -> u64)
{
	return impl_gpu_graph_add_subgraph(g, subgraph, a);
};

gpu_graph_add_pass ::= func(g : gpu_graph, p : gpu_pass, a : arena mut? -> u64)
{
	return impl_gpu_graph_add_pass(g, p, a);
};

// execute the gpu work (async) associated with a graph.
gpu_execute ::= func(g : gpu_graph, long : arena mut?, short : arena mut? -> gpu_err)
{
	return impl_gpu_execute(g, long, short);
};

// blocks the current thread until all gpu work associated with the graph to fully complete.
gpu_wait ::= func(g : gpu_graph -> v0)
{
	impl_gpu_wait(g);
};

gpu_hardware_count ::= func( -> u64)
{
	return impl_gpu_hardware_count();
};

gpu_iterate_hardware ::= func(array : gpu_hardware mut?, array_size : u64, a : arena mut? -> gpu_err)
{
	return impl_gpu_iterate_hardware(array, array_size, a);
};

// use one of the hardwares you retrieved via gpu_iterate_hardware
// gpu_err.fatal => you used this hardware earlier and did something so evil that the hardware itself is invalidated
// gpu_err.reqfailed => the hardware does not meet the requirements to be used
// gpu_err.cpuoom => not enough cpu memory
// gpu_err.gpuoom => not enough gpu memory
// gpu_err.unknown => internal error, upto you to figure out
gpu_use_hardware ::= func(hw : gpu_hardware, window : window -> gpu_err)
{
	return impl_gpu_use_hardware(hw, window);
};

gpu_create_pass ::= func(info : gpu_pass_info, long : arena mut?, short : arena mut? -> gpu_pass_result)
{
	return impl_gpu_create_pass(info, long, short);
};

// create a gpu buffer for use in one or more passes
gpu_create_buffer ::= func(info : gpu_resource_info, a : arena mut? -> gpu_resource_result)
{
	return impl_gpu_create_buffer(info, a);
};

gpu_create_image ::= func(info : gpu_resource_info, a : arena mut? -> gpu_resource_result)
{
	return impl_gpu_create_image(info, a);
};

gpu_resource_write ::= func(res : gpu_resource, data : v0? weak, data_size : u64, offset : u64 -> v0)
{
	impl_gpu_resource_write(res, data, data_size, offset);
};

gpu_resource_read ::= func(res : gpu_resource, buf : v0? weak, len : u64, offset : u64 -> v0)
{
	impl_gpu_resource_read(res, buf, len, offset);
};

gpu_resource_size ::= func(res : gpu_resource -> u64)
{
	return impl_gpu_resource_size(res);
};

gpu_resource_pointer ::= func(res : gpu_resource -> gpu_resource_pointer_result)
{
	return impl_gpu_resource_pointer(res);
};

gpu_map_resource ::= func(res : gpu_resource -> gpu_map_resource_result)
{
	return impl_gpu_map_resource(res);
};

// resizes a buffer.
// res => resource to resize. must be a buffer
// new_size => new size of the resource, in bytes
// long => arena which must outlive the buffer's lifetime
// short => scratch arena which can be cleared at any time
// [invalidates all previous mappings and mapped arenas]
gpu_resize_buffer ::= func(res : gpu_resource, new_size : u64, long : arena mut?, short : arena mut? -> v0)
{
	impl_gpu_resize_buffer(res, new_size, long, short);
};

// helper function that loads some .spv files from the file system
// vertex_spv_path => relative path to a .spv for the vertex shader. must exist.
// fragment_spv_path => relative path to a .spv for the fragment shader. must exist.
// a => arena whose lifetime constraints the result
gpu_load_shader_files ::= func(vertex_spv_path : u8?, fragment_spv_path : u8?, a : arena mut? -> gpu_shader_sources)
{
	return impl_gpu_load_shader_files(vertex_spv_path, fragment_spv_path, a);
};

// create a shader program from a vertex and fragment spv data
gpu_create_graphics_shader ::= func(vertex_source : u8?, vertex_source_len : u64, fragment_source : u8?, fragment_source_len : u64, a : arena mut? -> gpu_shader)
{
	return impl_gpu_create_graphics_shader(vertex_source, vertex_source_len, fragment_source, fragment_source_len, a);
};

// create a shader program from a compute spv data
gpu_create_compute_shader ::= func(compute_source : u8?, compute_source_len : u64, a : arena mut? -> gpu_shader)
{
	return impl_gpu_create_compute_shader(compute_source, compute_source_len, a);
};

gpu_appinfo ::= struct
{
	name : u8?;
	ver_maj : u32;
	ver_min : u32;
};

gpu_err ::= struct
{
	code : gpu_err_code;
	msg : u8?;
};

gpu_err_code ::= enum
{
	// something happened that i cant explain
	.unknown := 1;
	// one of the arguments or state was malformed in some way
	.malformed := 2;
	// forgot to initialise
	.notinit := 3;
	// out of cpu memory
	.cpuoom := 4;
	// out of gpu memory
	.gpuoom := 5;
	// fatal error has occurred, gpu state is now corrupt
	.fatal := 6;
	// a driver/hardware feature was required but not available. this is a sign the host machine does not support psygpu
	.reqfailed := 7;
};

gpu_cull ::= enum
{
	.none := 0;
	.back := 2;
	.front := 1;
	.both := 3;
};

gpu_draw_command ::= struct
{
	vertex_count : u32;
	instance_count : u32;
	first_vertex : u32;
	first_instance : u32;
};

gpu_draw_indexed_command ::= struct
{
	index_count : u32;
	instance_count : u32;
	first_index : u32;
	vertex_offset : s32;
	first_instance : u32;
};

gpu_graphics_state ::= struct
{
	clear_colour : f32[4];
	scissor : u32[4];
	colour_targets_data : gpu_resource?;
	colour_targets_count : u64;
	depth_target : gpu_resource;
	index_buffer : gpu_resource;
	draw_buffer : gpu_resource;
	culling : gpu_cull;
	static_tri_count : u64;
};

gpu_compute_state ::= struct
{
	kernelx : u32;
	kernely : u32;
	kernelz : u32;
};

gpu_hardware_type ::= enum
{
	.gpu := 0;
	.igpu := 1;
	.cpu := 2;
	.unknown := 3;
};

gpu_hardware_caps ::= enum
{
	.graphics_compute := 0;
	.graphics_only := 1;
	.compute_only := 2;
	.none := 3;
};

gpu_hardware ::= struct
{
	name : u8 mut?;
	target_heap_gpu : u64;
	target_heap_cpu : u64;
	vram_size_mib : u64;
	type : gpu_hardware_type;
	caps : gpu_hardware_caps;
	id : u32;
	native_handle : u64;
};

gpu_graph ::= enum
{
	.invalid := -1;
};

gpu_pass_info ::= struct
{
	graphics : gpu_graphics_state;
	compute : gpu_compute_state;
	shader : gpu_shader;
	resources_data : gpu_resource?;
	resources_count : u64;
	name : u8?;
};

gpu_pass ::= enum
{
	.invalid := -1;
	.present := -2;
};

gpu_pass_result ::= struct
{
	res : gpu_pass;
	err : gpu_err;
};

gpu_buffer_flag ::= enum
{
	.none := 0b0000;
	.dynamic := 0b0001;
	.index_buffer := 0b0010;
	.draw_buffer := 0b0100;
};

gpu_image_flag ::= enum
{
	.none := 0;
};

gpu_resource_flag ::= enum
{ 
	// ignore gpu_resource_info.data, fill size with zeroes.
	.zero_memory := 0b00000001;
};

gpu_resource_pointer_result ::= struct
{
	ptr : u8 mut? weak;
	err : gpu_err;
};

gpu_map_resource_result ::= struct
{
	mapping : arena;
	err : gpu_err;
};

gpu_image_type ::= enum
{
	.rgba := 0;
	.depth := 1;
};

gpu_resource_info ::= struct
{
	data : v0? weak;
	data_size : u64;
	image_dimensions : u32[2];
	image_type : gpu_image_type;
	flags : gpu_resource_flag;
	buffer_flags : gpu_buffer_flag;
	image_flags : gpu_image_flag;
	name : u8?;
};

gpu_resource ::= enum
{
	.invalid := -1;
	.window_resource := -2;
};

gpu_resource_result ::= struct
{
	res : gpu_resource;
	err : gpu_err;
};

gpu_shader_sources ::= struct
{
	vertex_spv_data : u8 mut?;
	vertex_spv_count : u64;
	fragment_spv_data : u8 mut?;
	fragment_spv_count : u64;
};

gpu_shader ::= enum
{
	.invalid := -1;
};

