descriptor : descriptor_state mut := zero;
descriptor_state ::= struct
{
	set_layouts : u64 mut[2];
	pools_data : u64 mut?;
	pools_count : u64;
	pools_cap : u64;
};

MAX_GLOBAL_IMAGE_COUNT ::= 8192;
MAX_IMAGE_COUNT_PER_PASS ::= 4096;

impl_new_descriptor_pool ::= func(a : arena mut? -> u64)
{
	if(descriptor.pools_cap == 0)
	{
		descriptor.pools_cap = 4;
		descriptor.pools_data = arena_alloc(a, descriptor.pools_cap * __sizeof(deref(descriptor.pools_data)));
	}
	if(descriptor.pools_count >= descriptor.pools_cap)
	{
		putzstr("todo: expand allocation of descriptor pool handles");
		__debugbreak();
	}

	image_limit ::= VkDescriptorPoolSize
	{
		.type := 1; // VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
		.descriptorCount := MAX_IMAGE_COUNT_PER_PASS;
	};
	create ::= VkDescriptorPoolCreateInfo
	{
		.sType := 33;
		.pNext := zero;
		.flags := 0x00000002;
		.maxSets := frame_overlap * 256;
		.poolSizeCount := 1;
		.pPoolSizes := ref image_limit;
	};
	newpool : u64 mut;
	vk_check(vk.create_descriptor_pool(hardware.used_device, ref create, zero, ref newpool));
	deref(descriptor.pools_data # (descriptor.pools_count)) = newpool;
	descriptor.pools_count = (descriptor.pools_count + 1);
	return newpool;
};

impl_try_allocate_descriptors ::= func(pool : u64, sets_data : u64 mut?, image_count : u32 -> bool)
{
	variable_counts : u32 mut[2];
	deref(variable_counts # 0) = image_count;
	deref(variable_counts # 1) = image_count;

	variable_alloc ::= VkDescriptorSetVariableDescriptorCountAllocateInfo
	{
		.sType := 1000161003;
		.pNext := zero;
		.descriptorSetCount := 2;
		.pDescriptorCounts := variable_counts # 0;
	};
	alloc ::= VkDescriptorSetAllocateInfo
	{
		.sType := 34;
		.pNext := (ref variable_alloc)@_;
		.descriptorPool := pool;
		.descriptorSetCount := 2;
		.pSetLayouts := descriptor.set_layouts # 0;
	};
	return (vk.allocate_descriptor_sets(hardware.used_device, ref alloc, sets_data)) == 0;
};

impl_passptr_get_image_count ::= func(passptr : pass_data_t? -> u32)
{
	pinfo ::= passptr->info;
	image_count : u32 mut := 0;

	counter : u64 mut;
	cur_resh : gpu_resource mut;
	resptr : resource_data_t? mut;
	for(counter = 0, counter < (pinfo.resources_count), counter = counter + 1)
	{
		cur_resh = deref((pinfo.resources_data) # counter);
		if(cur_resh != (gpu_resource.invalid))
		{
			if(cur_resh == (gpu_resource.window_resource))
			{
				image_count = image_count + 1;
			}
			else
			{
				resptr = (resource.data # (cur_resh@s64));
				if(!(resptr->is_buffer))
				{
					image_count = image_count + 1;
				}
			}
		}
	}
	return image_count;
};

impl_update_descriptors ::= func(passptr : pass_data_t mut?, long : arena mut?, short : arena mut? -> gpu_err)
{
	pinfo ::= passptr->info;
	image_count ::= impl_passptr_get_image_count(passptr);
	// assume allocations are all done
	// just doing writes
	// write to them.
	image_array_descriptor_binding ::= 1;
	image_writes : VkDescriptorImageInfo mut? := arena_alloc(short, __sizeof(VkDescriptorImageInfo) * image_count * frame_overlap);

	meta_buffer_write ::= VkDescriptorBufferInfo
	{
		.buffer := passptr->metabuf;
		.offset := 0;
		.range := ~0;
	};

	descriptor_writes : VkWriteDescriptorSet mut[4];
	// first write to the meta buffers.
	deref(descriptor_writes # 0) = VkWriteDescriptorSet
	{
		.sType := 35;
		.pNext := zero;
		.dstSet := deref(passptr->descriptor_sets # 0);
		.dstBinding := 0;
		.dstArrayElement := 0;
		.descriptorCount := 1;
		.descriptorType := 7; // VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
		.pImageInfo := zero;
		.pBufferInfo := ref meta_buffer_write;
		.pTexelBufferView := zero;
	};

	deref(descriptor_writes # 1) = VkWriteDescriptorSet
	{
		.sType := 35;
		.pNext := zero;
		.dstSet := deref(passptr->descriptor_sets # 1);
		.dstBinding := 0;
		.dstArrayElement := 0;
		.descriptorCount := 1;
		.descriptorType := 7; // VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
		.pImageInfo := zero;
		.pBufferInfo := ref meta_buffer_write;
		.pTexelBufferView := zero;
	};

	// now let's do the images.
	i : u32 mut;
	j : u64 mut;
	img_cursor : u64 mut := 0;
	cur_resh : gpu_resource mut;
	resptr : resource_data_t? mut;
	for(i = 0, i < frame_overlap, i = i + 1)
	{
		for(j = 0, j < (pinfo.resources_count), j = j + 1)
		{
			cur_resh = deref((pinfo.resources_data) # j);
			if(cur_resh != (gpu_resource.invalid))
			{
				if(cur_resh != (gpu_resource.window_resource))
				{
					resptr = (resource.data # (cur_resh@s64));
					if(!(resptr->is_buffer))
					{
						deref(image_writes # img_cursor) = VkDescriptorImageInfo
						{
							.sampler := resptr->sampler;
							.imageView := resptr->image_view;
							.imageLayout := 5; // VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
						};
						img_cursor = img_cursor + 1;
					}
				}
			}
		}
		deref(descriptor_writes # (2 + i)) = VkWriteDescriptorSet
		{
			.sType := 35;
			.pNext := zero;
			.dstSet := deref(passptr->descriptor_sets # i);
			.dstBinding := image_array_descriptor_binding;
			.dstArrayElement := 0;
			.descriptorCount := image_count;
			.descriptorType := 1; // VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
			.pImageInfo := image_writes # (i * image_count);
			.pBufferInfo := ref meta_buffer_write;
			.pTexelBufferView := zero;
		};
	}

	write_count : u32 mut := 4;
	if(image_count == 0)
	{
		write_count = 2;
	}
	vk.update_descriptor_sets(hardware.used_device, write_count, descriptor_writes # 0, 0, zero);
	return zero;
};

impl_populate_descriptors ::= func(passptr : pass_data_t mut?, long : arena mut?, short : arena mut? -> gpu_err)
{
	if(descriptor.pools_count == 0)
	{
		impl_new_descriptor_pool(long);
	}
	pool : u64 mut := deref(descriptor.pools_data # (descriptor.pools_count - 1));
	image_count ::= impl_passptr_get_image_count(passptr);

	// allocate descriptors
	retry_count : u64 mut := 0;
	MAX_RETRIES ::= 3;
	alloc_success : bool mut := impl_try_allocate_descriptors(pool, passptr->descriptor_sets # 0, image_count);
	while(!alloc_success)
	{
		if(retry_count >= MAX_RETRIES)
		{
			return gpu_err
			{
				.code := gpu_err_code.unknown;
				.msg := "empty descriptor pool was too small to allocate descriptors for a pass. hardcoded limits have been reached - you probably have way way too many images associated with a pass";
			};
		}
		pool = impl_new_descriptor_pool(long);
		alloc_success = impl_try_allocate_descriptors(pool, passptr->descriptor_sets # 0, image_count);
		retry_count = retry_count + 1;
	}

	return impl_update_descriptors(passptr, long, short);
};

