impl_ren_create_mesh_storage ::= func(info : ren_mesh_storage_info -> ren_mesh_storage)
{
	initial_vertex_capacity ::= 1024;
	initial_index_capacity ::= 2048;
	initial_mesh_capacity ::= 128;
	vb ::= gpu_create_buffer(gpu_resource_info
	{
		.data_size := info.vertex_size_bytes * initial_vertex_capacity;
		.flags := gpu_resource_flag.zero_memory;
		.buffer_flags := zero;
		.name := "Vertex Buffer";
	}, global_arena);
	ib ::= gpu_create_buffer(gpu_resource_info
	{
		.data_size := __sizeof(u32) * initial_index_capacity;
		.flags := gpu_resource_flag.zero_memory;
		.buffer_flags := gpu_buffer_flag.index_buffer;
		.name := "Index Buffer";
	}, global_arena);

	return ren_mesh_storage
	{
		.info := info;
		.vertex_buffer := vb.res;
		.vertex_cursor := 0;
		.index_buffer := ib.res;
		.index_cursor := 0;
		.meshes := arena_alloc(global_arena, __sizeof(mesh_locator) * initial_mesh_capacity);
		.meshes_count := 0;
		.meshes_cap := initial_mesh_capacity;
	};
};

impl_ren_mesh_storage_add ::= func(m : ren_mesh_storage mut?, data : ren_mesh_data -> ren_mesh_handle)
{
	// find a gap in the vertex + index buffers and store them there
	voff ::= impl_ren_mesh_storage_find_vtx_gap(m, data.vertices_count);
	ioff ::= impl_ren_mesh_storage_find_idx_gap(m, data.indices_count);

	// make sure we have enough space
	gpu_resize_buffer_at_least(m->vertex_buffer, (data.vertices_count + voff) * ren_mesh_storage_vertex_size(m), global_arena, frame_arena);
	gpu_resize_buffer_at_least(m->index_buffer, (data.indices_count + ioff) * ren_mesh_storage_index_size(m), global_arena, frame_arena);

	// todo: when we support gaps in buffers maybe we check for -1 (i.e no gap)
	// use that to populate a mesh_locator
	loc ::= mesh_locator
	{
		.voff := voff;
		.vlen := data.vertices_count;
		.ioff := ioff;
		.ilen := data.indices_count;
	};
	// add the mesh_locator to ren_mesh_storage.meshes and return _in_ren_mesh_handle(idx within meshes)
	idx ::= m->meshes_count;
	m->meshes_count = (m->meshes_count + 1);
	deref(m->meshes # idx) = loc;

	// do the writes
	gpu_resource_write(m->vertex_buffer, data.vertices, data.vertices_count * ren_mesh_storage_vertex_size(m), voff * ren_mesh_storage_vertex_size(m));
	gpu_resource_write(m->index_buffer, data.indices, data.indices_count * ren_mesh_storage_index_size(m), ioff * ren_mesh_storage_index_size(m));
	m->vertex_cursor = (m->vertex_cursor + (data.vertices_count));
	m->index_cursor = (m->index_cursor + (data.indices_count));
	return _in_ren_mesh_handle(idx);
};

impl_ren_mesh_storage_vertex_size ::= func(m : ren_mesh_storage? -> u64)
{
	return m->info.vertex_size_bytes;
};

impl_ren_mesh_storage_index_size ::= func(m : ren_mesh_storage? -> u64)
{
	return __sizeof(u32);
};

impl_ren_mesh_storage_get_mesh ::= func(m : ren_mesh_storage?, h : ren_mesh_handle -> mesh_locator)
{
	idx ::= _out_ren_mesh_handle(h);
	return deref(m->meshes # idx);
};

_in_ren_mesh_handle ::= func(idx : u64 -> ren_mesh_handle)
{
	return (idx + 1)@ren_mesh_handle;
};

_out_ren_mesh_handle ::= func(handle : ren_mesh_handle -> u64)
{
	return ((handle)@s64 - 1)@_;
};

impl_ren_mesh_storage_find_vtx_gap ::= func(m : ren_mesh_storage?, vertex_count : u64 -> u64)
{
	return m->vertex_cursor;
};

impl_ren_mesh_storage_find_idx_gap ::= func(m : ren_mesh_storage?, index_count : u64 -> u64)
{
	return m->index_cursor;
};

